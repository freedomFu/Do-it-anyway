# Static Program Analysis - Data Flow Analysis - Applications

> æ•°æ®æµåˆ†ææ˜¯é™æ€åˆ†ææ˜¯éå¸¸é‡è¦çš„

## Overview of Data Flow Analysis

```html
Data Flow Analysis
ğŸ‘‡
How Data Flow on CFG?
ğŸ‘‡
How application-specific Data Flows through the Nodes (BBs/statements) and Edges (control flows) of CFG (a program)?
ğŸ‘‡
1. application-specific Data å¯¹æ•°æ®è¿›è¡Œ Abstraction ä¾‹å¦‚ +, -, 0, unknown, undefined
2. Flows é™æ€åˆ†æä¸­æ‰€æœ‰å¯èƒ½çš„ç»“æœéƒ½éœ€è¦è€ƒè™‘è¿›å»ï¼Œè¿›è¡Œ Over-approximation æˆ–è€… åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹è¿›è¡Œ Must-approximation æ­¤å¤„æ›´æ”¹ä¸ºï¼šSafe-approximation
- may analysis: safe=over
- must analysis: safe=under 
3. è¿‘ä¼¼çš„ä¸¤ä¸ªå…³é”®ç‚¹
- Nodes: Transfer function ä¾‹å¦‚ + op - = -; + op + = +
- Edges: Control-flow handling ä¾‹å¦‚ union the signs at merges
```

**Over-approximation** æ˜¯ç»å¤§å¤šæ•°é™æ€åˆ†æä¸­éœ€è¦è€ƒè™‘çš„å†…å®¹ï¼Œå±äº *may analysis*

- **may analysis:** outputs information that may be true (over-approximation)
- **must analysis:** outputs information that must be true (under-approximation)
- Over- and under-approximations are **both for safety of analysis**

> different **data-flow analysis applications** have
> different data abstraction and 
> different flow safe-approximation strategies, i.e., 
> different transfer functions and control-flow handlings

## Preliminaries of Data Flow Analysis

> ä¸ºäº†åç»­æ›´åŠ ç®€ä¾¿çš„äº¤æµ

### Input and Output States 

- Each execution of an IR statement transforms an *input state* to a new *output state*
- The input (output) state is associated with the *program point* before (after) the statement.
- ç¨‹åºä¸»è¦å­˜åœ¨å‡ ç§å¯èƒ½çš„æ‰§è¡Œé¡ºåº
  - é¡ºåºæ‰§è¡Œ IN[s2] = OUT[s1]
  - åˆ†å‰æ‰§è¡Œ IN[s2] = IN[s3] = OUT[s1]
  - æ±‡èšæ‰§è¡Œ IN[s2] = OUT[s1] ^ OUT[s3]  
    - éœ€è¦å¯¹æ¥è‡ªä¸¤ä¸ªæ¥æºçš„æ•°æ®è¿›è¡Œå¤„ç†ï¼Œå¤„ç†çš„æ–¹æ³•æ˜¯ meet operation

![](./figs/03_input_output_states.png)

In each data-flow analysis application, we associate with every program point a *data-flow value* that represents an *abstraction* of the set of all possible *program states* that can be observed for that point.

```java
// ğŸ”´ ä»£è¡¨å½“å‰çš„ program states  æŠŠæ•°æ®ä¿¡æ¯è¿›è¡ŒæŠ½è±¡ï¼Œå½¢æˆ data-flow values
x = 10; 
ğŸ”´ ğŸ‘‰ x = +, y = âŠ¥
y = -1;
ğŸ”´ ğŸ‘‰ x = +, y = -
x = y;
ğŸ”´ ğŸ‘‰ x = -, y = -
x = x / y;
ğŸ”´ ğŸ‘‰ x = +, y = -
```

![](./figs/03_data_flow_analysis_applications_example.png)

Data-flow analysis is to **find a solution** to a set of *safe-approximation-directed constraints* on the IN[s]' and OUT[s]'s, for *all statements*.
- *constraints* based on semantics of statements (*transfer functions*)
- *constraints* based on the *flows of control*

### Notations for Transfer Function's Constraints 

**Forward Analysis** $OUT[s] = f_s(IN[s])$

**Backward Analysis** $IN[s] = f_s(OUT[s])$

![](./figs/03_fs_bs.png)

### Notations for Control Flow's Constraints 

**Control flow within a BB**

$IN[S_{i+1}] = OUT[S_i], for all i = 1, 2, ..., n-1$

**Control flow among BBs**

$IN[B] = IN[S_1]$

$OUT[B] = OUT[S_n]$

*Forward Analysis*

æ³¨æ„å…ˆæ‰§è¡Œ $f_{S_1}$

$OUT[B] = f_B(IN[B]), f_B=f_{S_n} Â· ... Â· f_{S_2} Â· f_{S_1}$

$IN[B] = âˆ§_{P\_a\_predecessor\_of\_B} OUT[P]$

> The meet operator âˆ§ is used to summarize the contributions from different paths at the confluence of those paths 

*Backward Analysis*

æ³¨æ„å…ˆæ‰§è¡Œ $f_{S_n}$

$IN[B] = f_B(OUT[B]), f_B=f_{S_1} Â· ... Â· f_{S_{n-1}} Â· f_{S_n}$

$OUT[B] = âˆ§_{S\_a\_successor\_of\_B} IN[S]$

![](./figs/03_cf_constraints.png)

## Data Flow Analysis Applications 

> æ­¤å¤„ä¸åŒ…æ‹¬å¯¹äº `Method Calls` å’Œ `Aliases` çš„é—®é¢˜

### Reaching Definitions Analysis

> ç¼–è¯‘ä¼˜åŒ– å’Œ ç®€å•çš„é”™è¯¯æ£€æµ‹éƒ½å¯ä»¥ä½¿ç”¨

A **definition d** at program point p *reaches* a point q if there is a path from p to q such that **d** is not 'killed' along that path.

- A **definition of a variable** v is statement that assigns a value to v
- Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that no new definition of v appears on that path 
  - å³æ²¡æœ‰æ–°çš„å£°æ˜çš„äº§ç”Ÿ

![](./figs/03_reaching_definitions_kill_path.png)

**ä¸€ä¸ªåº”ç”¨çš„ä¾‹å­**

Reaching definitions can be used to **detect possible undefined variables**. e.g., introduce a dummy definition for each variable v at the entry of CFG, and if the dummy definition of v reaches a point p where v is used, then v may be used before definition (as *undefined* reaches v). è¿™æ˜¯ä¸€ä¸ª **may analysis**

#### Understanding Reaching Definitions

Data Flow Values/Facts

**Abstraction**

- The definitions of all the variables in a program
- Can be represented by bit vectors
  - e.g., D1, D2, D3, D4, ..., D100 (100 definitions) å¯¹åº” 100 ä¸ª bits 
    - Bit i from the left represents definition Di

**Safe-approximation**

**D:** v = x op y 

This statement "generates" a definition D of variable v and **"kills" all the other definitions** in the program that define variable v, while leaving the remaining incoming definitions unaffected.

*Transfer Function:* $OUT[B] = gen_B âˆª (IN[B] - kill_B)$

ä¾‹å­ï¼š

![](./figs/03_transfer_func_examples.png)

*Control Flow:*

Forward Analysis: $IN[B] = âˆª_{P a\_predecessor\_ of\_B} OUT[P]$ æ ¹æ®ä¸Šè¿°çš„åˆ†æéœ€æ±‚ï¼Œè¿™åº”è¯¥æ˜¯ä¸€ä¸ª Forward Analysis

> A definition reaches a program point as long as there exists at least one path along which the definition reaches.

#### Algorithm of Reaching Definitions Analysis

**INPUT:** CFG ($kill_B$ and $gen_B$ computed for each basic block B)

**OUTPUT:** IN[B] and OUT[B] for each basic block B 

**METHOD:** 

```java
// ä¸ºä»€ä¹ˆåˆå§‹åŒ–ä¸ºç©ºé›†ï¼Ÿ
// Answer: Entry æ˜¯è™šæ‹Ÿå…¥å£ï¼ŒEntryæ˜¯æ²¡æœ‰Definitionå’ŒStatementï¼Œå› æ­¤ä¸€å®šä¸ºç©ºï¼›å¯ä»¥è®¤ä¸ºæ˜¯ boundary condition
OUT[entry] = âŒ€;
// ä¸ºä»€ä¹ˆ entry è¦è¢«å‰”é™¤ï¼Ÿ
// Answer: åœ¨ may analysis ä¸­ï¼Œé€šå¸¸ä¸ºç©ºï¼Œè€Œ must analysis åˆ™é€šå¸¸ä¸º âŠ¤ï¼Œå› æ­¤ä¸ºäº†è¾¾åˆ°ç®—æ³•æ¨¡æ¿ï¼Œæ­¤å¤„åˆ†å¼€èµ‹å€¼
for (each basic block B\entry)
    // ä¸ºä»€ä¹ˆ OUT[B] è¦åˆå§‹åŒ–ä¸ºç©ºé›†ï¼Ÿ
    // Answer: Basic Block åœ¨ may analysis ä¸­ï¼Œé€šå¸¸ä¸ºç©ºï¼Œè€Œ must analysis åˆ™é€šå¸¸ä¸º âŠ¤
    OUT[B] = âŒ€;

// ä¸ºä»€ä¹ˆè¿™é‡Œå¾ªç¯ä¼šåœæ­¢ï¼Ÿ
// å½“ä¸ä¸Šæ¬¡çš„OUTä¸åŒï¼Œåˆ™æ˜¯å‘ç”Ÿå˜åŒ–
// æ ¹æ®åç»­çš„ä¾‹å­ï¼Œå¯ä»¥å‘ç°å½“ OUT ä¸å˜æ—¶ï¼Œ
while (changes to any OUT occur)
    for (each basic block B\entry) {
        // Control Flow
        IN[B] = â‹ƒ_{P a predecessor of B} OUT[P]
        // Transfer Function
        OUT[B] = gen_B â‹ƒ (IN[B] - kill_B)
    }
```

**ä¾‹å­ï¼š**

8 ä¸ª Definitionï¼Œ5 ä¸ª Basic Blocks

å¯¹åº”çš„çœŸå®ç¨‹åº

```java
D1
D2
do {
    D3
    D4
    if (...) {
        D5
        D6
    } else {
        D7
        break
    }
} while (...)
D8
```

**Definition ç”¨ bit vector è¡¨ç¤ºã€‚0ä»£è¡¨ä¸èƒ½åˆ°è¾¾ï¼Œ1ä»£è¡¨èƒ½è¾¾åˆ°**

In each data-flow analysis application, we associate with every program point a **data-flow value** that represents an *abstraction* of the set of all possible **program states** that can be observed for that point.

Data-flow analysis is to **find a solution** to a set of *safe-approximation-directed constraints* on the IN[s]' and OUT[s]'s, for *all statements*.
- *constraints* based on semantics of statements (*transfer functions*) 
- *constraints* based on the *flows of control*  

![](./figs/03_iteration_1.png)

![](./figs/03_iteration_2.png)

![](./figs/03_iteration_3.png) 

> å¯¹äº Reaching Definition ä»»åŠ¡ï¼Œå½“è¾“å…¥å›ºå®šæ—¶ï¼Œè¾“å‡ºå®é™…ä¸Šä¸€å®šæ˜¯ç¡®å®šçš„
> å› æ­¤ï¼Œæœ€åä¸€æ¬¡ä¸å˜çš„ï¼Œå°±æ˜¯ Final Result

**è¿­ä»£æœ€åä¸ºä»€ä¹ˆèƒ½åœï¼Ÿ**

```java
more facts
ğŸ‘‡
OUT[S] = gen_S â‹ƒ (IN[S] - kill_S)
```

![](./figs/03_more_facts.png)

- $gen_S$ and $kill_S$ remain unchanged è¿™ä¸¤è€…æ˜¯ä¸å˜åŒ–çš„
- When more facts flow in IN[S], the "more facts" either 
  - is killed, or è¦ä¹ˆè¢« killed 
  - flows to OUT[S] ($survivor_S$) å­˜æ´»çš„å†…å®¹ä¼šå˜æˆ OUTï¼Œé‚£ä¹ˆå°±ä¼šä¸€ç›´åœç•™åœ¨è¿™é‡Œ
- When a fact is addd to OUT[S], through either $gen_S$, or $survivor_S$, **it stays there forever**
- Thus OUT[S] never shrinks (e.g., 0â†’1, or 1â†’1) å› ä¸ºæ˜¯éœ€è¦é¦–å…ˆ kill æ‰ä¹‹å‰çš„ï¼Œå†å¢åŠ æ–°çš„ï¼Œå› æ­¤ä¸å¯èƒ½ 1â†’0
- As the set of facts is finite (e.g., all definitions in the program), there must exist a pass of iteration during which nothing is added to any OUT, and then the algorithm terminates

---

**Is it Safe to terminate by this condition?**

- IN[B] = â‹ƒ_{P a predecessor of B} OUT[P]
  - IN' will not change if OUT's do not change
- OUT[B] = gen_B â‹ƒ (IN[B] - kill_B)
  - OUT's will not change if IN's do not change

- æ­¤æ—¶ç®—æ³•åˆ°è¾¾äº†ä¸€ä¸ªä¸åŠ¨ç‚¹ Reach a **fixed point**ï¼Œä¹Ÿä¸å•è°ƒæ€§ç›¸å…³ Also related with monotonicity
- **åªæœ‰ä¸€ä¸ªä¸åŠ¨ç‚¹å—ï¼Ÿå•è°ƒæ€§å¦‚ä½•ç†è§£ï¼Ÿ**

### Live Variables Analysis

Live variables analysis tells whether the vaule of **variable v** at **program point p** could be used along some path in CFG starting at p.
If so, v is live at p; otherwise, v is dead at p.

- Information of live variables can be used for register allocations. e.g., at some point all registers are full and we need to use one, then we should favor using a register with a dead value.
- åœ¨æ­¤å¤„ï¼Œéœ€è¦æ³¨æ„ v åœ¨æ­¤ Path ä¸­åº”è¯¥ä¸ä¼šè¢«é‡æ–°å®šä¹‰ï¼Œæ‰ä¼šè¢«è®¤ä¸ºæ˜¯ live çš„

![](./figs/03_live_variable_analysis.png)

#### Understanding Live Variables Analysis

**Abstraction**

- Data Flow Values/Facts 
  - All the variables in a program
  - Can be represented by bit vectors 
    - e.g., V1, V2, V3, V4, ..., V100 (100variables)  
    - Bit i from the left represents variable Vi

**Safe-approximation**

<u>åº”è¯¥ä½¿ç”¨ Forward è¿˜æ˜¯ Backward?</u> åº”è¯¥ç”¨ backwardï¼ŒåŸå› æ˜¯ å¯ä»¥ç›´æ¥ä» use çš„åœ°æ–¹å‘å‰å»æ‰¾ï¼Œè€Œä¸ç”¨ä»å¤´å¼€å§‹æ‰¾åˆ°æœ€åæ‰çœ‹åˆ°

<u>åº”è¯¥ä½¿ç”¨ may analysisï¼Œå³åªéœ€è¦æœ‰ä¸€æ¡ä½¿ç”¨åˆ™è®¤ä¸ºæœ‰ use çš„æƒ…å†µ</u>

OUT[B] = â‹ƒ_{S a successor of B} IN[S]

![](./figs/03_understanding_lva.png)

**Tip:** determine whether the variable v in some register R is live, or should we delete the value 3 of v in R, at the point of IN[B]?  **Yes:** IN[B] = {v}; **No:** IN[B] = {}

1. k = n        ğŸ‘‰ IN[B] = {v} å› ä¸ºåœ¨åç»­ `...=v` ä½¿ç”¨åˆ°äº†ï¼Œè€Œä¸” v æ²¡æœ‰è¢«é‡æ–°å®šä¹‰
2. k = v        ğŸ‘‰ IN[B] = {v} æ²¡æœ‰ä»€ä¹ˆç–‘é—®ï¼Œä¹Ÿæ˜¯ v
3. v = 2        ğŸ‘‰ IN[B] = { } å› ä¸ºæ¶‰åŠé‡æ–°å®šä¹‰ï¼Œå› æ­¤æ­¤å¤„ä¸º ç©º
4. v = v - 1    ğŸ‘‰ IN[B] = {v} åœ¨ re-define ä¹‹å‰ä½¿ç”¨ï¼Œå› æ­¤ä¸º v
5. v = 2; k = v ğŸ‘‰ IN[B] = { } å…ˆ re-define åä½¿ç”¨ï¼Œå› æ­¤ä¸º ç©º
6. k = v; v = 2 ğŸ‘‰ IN[B] = {v} åœ¨ re-define ä¹‹å‰ä½¿ç”¨ï¼Œå› æ­¤ä¸º v

*Transfer Functions:* $IN[B] = use_B âˆª (OUT[B] - def_B)$

> ä¸€èˆ¬éƒ½æ˜¯å‡å»ä¸€éƒ¨åˆ†å†unionåˆ é™¤çš„

- $def_B$: It is redefined in B
- $OUT[B] - def_B$: It is live coming out of B and is not re-defined in B
- $use_B$: It is used before re-definition in B

#### Algorithm of Live Variables Analysis

**INPUT:** CFG ($def_B$ and $use_B$ computed for each basic block B)

**OUTPUT:** IN[B] and OUT[B] for each basic block B 

**METHOD:** 

```java
// boundary åˆå§‹åŒ–
IN[exit] = âŒ€;

for (each basic block B\exit)
    // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œmay analysis æ˜¯ ç©ºï¼Œ must analysis æ˜¯ 111111... å…¨é›†
    IN[B] = âŒ€;

while (changes to any IN occur)
    for (each basic block B\exit) {
        // Control Flow
        OUT[B] = â‹ƒ_{S a successor of B} IN[S]
        // Transfer Function
        IN[B] = use_B âˆª (OUT[B] - def_B)
    }
```

![](./figs/03_lv_01.png)

![](./figs/03_lv_02.png)

![](./figs/03_lv_03.png)

### Available Expressions Analysis

An expression `x op y` is **available** at program point if (1) **all** paths from the entry to p **must** pass through the evaluation of `x op y`, and (2) after the last evaluation of `x op y`, there is no redefinition of x or y.

- This definition means at program p, we can replace expression `x op y` by the result of its last evaluation.
- The information of available expressions can be used for detecting global common subexpressions.

#### Understanding Available Expressions Analysis

**Abstraction**

Data Flow Values/Facts:

- All the expressions in a program 
- Can be represented by bit vectors 
  - e.g., E1, E2, E3, E4, ..., E100 (100 expressions)
  - Bit i from the left represents expression Ei

**Safe-approximation**

```java
IN = {a + b}
â†“
a = x op y
â†“
OUT = {x op y}
```

- Add to OUT the expression `x op y` (**gen**)
- Delete from IN any expression involving variable `a` (**kill**)

*Transfer Functions:* $OUT[B] = gen_B â‹ƒ (IN[B] - kill_B)$

IN[B] = â‹‚ _ {P a predecessor of B} OUT[P]

- æ­¤å¤„ä½¿ç”¨äº¤é›†ï¼šAll paths from entry to point p must pass through the evaluation of `x op y`
- For safety of the analysis, it may report an expression as unavailable even if it is truly available 
  - (must analysis â†’ under-approximation)
  - ä¾‹å¦‚ï¼šå®æ„¿å…è®¸æ¼æŠ¥ï¼Œä¹Ÿä¸å…è®¸å‡ºé”™
  - ![](./figs/03_aea_wrong_example.png)

*An Example:*

![](./figs/03_aea_example.png)

![](./figs/03_aea_example_2.png)

#### Algorithm of Available Expressions Analysis

**INPUT:** CFG ($kill_B$ and $gen_B$ computed for each basic block B)

**OUTPUT:** IN[B] and OUT[B] for each basic block B 

**METHOD:** 

```java
OUT[entry] = âŒ€;

for (each basic block B\entry)
    OUT[B] = U; // å…¨é›†

while (changes to any OUT occur)
    for (each basic block B\entry) {
        // Control Flow
        IN[B] = â‹‚ _ {P a predecessor of B} OUT[P]
        // Transfer Function
        OUT[B] = gen_B â‹ƒ (IN[B] - kill_B)
    }
```

![](./figs/03_aea_01.png)

![](./figs/03_aea_02.png)

---

### Analysis Comparison (è¿™ä¸ªæ˜¯éœ€è¦è®°å¿†ä½çš„)


|                  | Reaching Definitions       | Live Variables             | Available Expressions      |
| -----            | ----                       | ----                       | ---                        |
| Domain           | Set of Definitions         | Set of Variables           | Set of Expressions         |
| Direction        | Forwards                   | Backwards                  | Forwards                   |
| May/Must         | May                        | May                        | Must                       |
| Boundary         | OUT[Entry]=Empty Set       | IN[Exit]=Empty Set         | OUT[Entry]=Empty Set       |
| Initialization   | OUT[B]=Empty Set           | IN[B]=Empty Set            | OUT[B]=Union Set           |
| Transfer Function| OUT[B]=gen_Bâ‹ƒ(IN[B]-kill_B)| IN[B]=use_Bâ‹ƒ(OUT[B]-def_B) | OUT[B]=gen_Bâ‹ƒ(IN[B]-kill_B)|
| Meet             | Union                      | Union                      | Intersection               |

## é—®é¢˜

> æ€»ä½“ä¸ºä¸Šè¿°çš„æ¯”è¾ƒè¡¨æ ¼

- Understand the three data flow analyses:
  - reaching definitions
  - live variables 
  - available expressions
- Can tell the differences and similarities of the three data flow analyses
- Understand the iterative algorithm and can tell why it is able to terminate