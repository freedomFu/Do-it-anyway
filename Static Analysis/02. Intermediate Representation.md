# Static Program Analysis - Intermediate Representation (IR)

## Compilers and Static Analyzers 

### Compiler 

```shell
Source Code
ğŸ‘‡
Scanner: Lexical Analysis è¯æ³•åˆ†æ (åˆ©ç”¨æ­£åˆ™è¡¨è¾¾å¼ Regular Expression)
ğŸ‘‡ å¦‚æœé€šè¿‡è¯æ³•åˆ†æï¼Œæ¯ä¸ªå•è¯éƒ½ä¼šæ„æˆTokens
Parser: Syntax Analysis è¯­æ³•åˆ†æ (åˆ©ç”¨ä¸Šä¸‹æ–‡æ— å…³æ–‡æ³• Context-Free Grammar)
ğŸ‘‡ å¦‚æœé€šè¿‡è¯­æ³•åˆ†æï¼Œä¼šå½¢æˆæŠ½è±¡è¯­æ³•æ ‘ AST
Type Checker: Semantic Analysis è¯­ä¹‰åˆ†æ (åˆ©ç”¨å±æ€§è¯­æ³• Attribute Grammar)
ğŸ‘‡ å¦‚æœé€šè¿‡è¯­ä¹‰åˆ†æï¼Œä¼šç”Ÿæˆ Decorated AST 
Translator
ğŸ‘‡ é€šè¿‡è½¬æ¢å™¨è½¬æ¢ç¨‹IRï¼Œé€šå¸¸æŒ‡ä¸‰åœ°å€ç  
Code Generator ç»§ç»­æŠŠä¸‰åœ°å€ç ç”ŸæˆMachine code
ğŸ‘‡
Machine Code
```

ä¸Šè¿° IR ï¼Œæ˜¯ Static Analysis éå¸¸é‡è¦çš„ï¼Œä¾‹å¦‚è¿›è¡Œ code optimization ï¼Œç”šè‡³æ˜¯å®‰å…¨æ¼æ´ï¼Œä¹Ÿéœ€è¦è¿›è¡Œä¸Šè¿°æ­¥éª¤ç›´åˆ°å¾—åˆ°ä¸€ä¸ªåˆæ³•çš„ IR 

## AST vs. IR

`do i=i+1; while (a[i]<v);`

**AST:** æŠ½è±¡è¯­æ³•æ ‘

- high-level and closed to grammar structure
- usually language dependent
- suitable for fast type checking
- lack of control flow information 

**IR: (3-address form)**

- low-level and closed to machine code 
- usually language independent
- compact and uniform
- contains control flow information 
- **usually considered as the basis for static analysis**

```python
1: i = i+1
2: t1 = a[i]
3: if t1 < v goto 1
```

![](./figs/02_AST_IR.png)

## IR: Three-Address Code (3AC)

**There is at most one operator on the right side of an instruction.** è½¬åŒ–é€šå¸¸éœ€è¦å¼•å…¥ä¸´æ—¶å˜é‡

```python 
t2 = a + b + 3
ğŸ‘‡
t1 = a + b 
t2 = t1 + 3
```

### Why called 3-address?

Each 3AC contains at most 3 addresses. **Address** can be one of the following:

- Name: a, b
- Constant: 3
- Compiler-generated temporary: t1, t2 

Each type of instructions has its own 3AC form.

### Some Common 3AC Forms

```python
x = y bop z 
x = uop y 
x = y
goto L 
if x goto L
if x rop y goto L
```

**x, y, z: addresses**

- bop: binary arithmetic or logical operation
- uop: unary operation (minus è´Ÿæ•°, negation å–å, casting ç±»å‹è½¬æ¢) 
- L: a label to represent a program location 
- rop: relational operator (>, <, ==, >=, <=, etc.)
- goto L: unconditional jump
- if ... goto L: conditional jump 

## 3AC in Real Static Analyzer: Soot 

3AC in real-world complicated forms

### Soot and Its IR: Jimple

Soot: Most popular static analysis framework for Java 

https://github.com/Sable/soot
https://github.com/Sable/soot/wiki/Tutorials

Soot's IR is Jimple: **typed** 3-address code 

**Example 1: For Loop**

æºä»£ç 

```java
package nju.sa.examples;
public class ForLoop3AC {
    public static void main(String[] args) {
        int x = 0;
        for (int i = 0; i < 10; i++) {
            x = x + 1;
        }
    }
}
```
ä¸‰åœ°å€ç 

```java
public static void main(java.lang.String[]) {
    java.lang.String[] r0;
    int i1;

    r0 := @parameter0: java.lang.String[];
    i1 = 0;

label1:
    if i1 >= 10 goto label2;
    i1 = i1 + 1;
    goto label1;

label2:
    return;
}
```
**Example 2: Do-While Loop**

æºä»£ç 

```java
package nju.sa.examples;
public class DoWhileLoop3AC {
    public static void main(String[] args) {
        int [] arr = new int[10];
        int i = 0;
        do {
            i = i + 1;
        } while (arr[i] < 10);
    }
}
```

ä¸‰åœ°å€ç 

```java
public static void main(java.lang.String[]) {
    java.lang.String[] r0;
    int[] r1;
    int $i0, i1;

    r0 := @parameter0: java.lang.String[];
    r1 = newarray (int)[10];

    i1 = 0;

label1:
    i1 = i1 + 1;
    $i0 = r1[i1];
    if $i0 < 10 goto label1;
    
    return;
}
```

**Example 3: Method Call**

æºä»£ç 

```java
package nju.sa.examples;
public class MethodCall3AC {

    String foo (String para1, String para2) {
        return para1 + " " + para2;
    }

    public static void main(String[] args) {
        MethodCall3AC mc = new MethodCall3AC();
        String result = mc.foo("hello", "world");
    }
}
```

ä¸‰åœ°å€ç 

```java
java.lang.String foo (java.lang.String, java.lang.String) {
    nju.sa.examples.MethodCall3AC r0;
    java.lang.String r1, r2, $r7;
    java.lang.StringBuilder $r3, $r4, $r5, $r6;

    r0 := @this: nju.sa.examples.MethodCall3AC;
    r1 := @parameter0: java.lang.String;
    r2 := @parameter1: java.lang.String;
    $r3 = new java.lang.StringBuilder;

    specialinvoke $r3.<java.lang.StringBuilder: void <init>()>();

    $r4 = virtualinvoke $r3.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r1);
    $r5 = virtualinvoke $r4.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(" ");
    $r6 = virtualinvoke $r5.<java.lang.StringBuilder: java.lang.StringBuilder append(java.lang.String)>(r2);
    $r7 = virtualinvoke $r6.<java.lang.StringBuilder: java.lang.String toString()>();

    return $r7;
}

public static void main (java.lang.String[]) {
    java.lang.String[] r0;
    nju.sa.examples.MethodCall3AC $r3;

    r0 := @parameter0: java.lang.String[];

    $r3 = new nju.sa.examples.MethodCall3AC;

    specialinvoke $r3.<nju.sa.examples.MethodCall3AC: void <init>()>();

    virtualinvoke $r3.<nju.sa.examples.MethodCall3AC: java.lang.String foo(java.lang.String, java.lang.String)>("hello", "world");

    return;
}
```

**JVMä¸­ä¸»è¦çš„å››ç§æ–¹æ³•è°ƒç”¨**

- invokespecial: call constructor, call superclass methods, call private methods
- invokevirtual: instance methods call (virtual dispatch) å¸¸ç”¨çš„æ–¹æ³•è°ƒç”¨
- invokeinterface: cannot optimization, checking interface implementation 
- invokestatic: call static methods 

Java 7 ä¹‹åè¿˜å¼•å…¥ï¼š

- invokedynamic ğŸ‘‰ åŸæœ¬ Java static typing, éœ€è¦ dynamic language runs on JVM

**<>ä¸­å†…å®¹ç§°ä¸ºMethodçš„Signature:** method signature é€šå¸¸åŒ…æ‹¬ï¼š

- class name:
  - return type method name (parameter1 type, parameter2 type, ...)


**Example 4: Class**

æºä»£ç 

```java
package nju.sa.examples;
public class Class3AC {
    public static final double pi = 3.14;
    public static void main(String[] args) {}
}
```

ä¸‰åœ°å€ç 

```java
public class nju.sa.examples.Class3AC extends java.lang.Object {
    public static final double pi;
    
    public void <init>() {
        nju.sa.examples.Class3AC r0;
        r0 := @this: nju.sa.examples.Class3AC;
        specialinvoke 30.<java.lang.Object: void <init>()>();
        return;
    }

    public static void main (java.lang.String[]) {
        java.lang.String[] r0;
        r0 := @parameter0: java.lang.String[];
        return ;
    }
    // ç±»çš„é™æ€åˆå§‹åŒ–å‡½æ•°
    // å¼•ç”¨ä¸€ä¸ªå˜é‡çš„æ—¶å€™ï¼Œä¼šæŠŠè¿™ä¸ªå˜é‡åŠ è½½è¿›æ¥
    public static void <clinit>() {
        <nju.sa.examples.Class3AC: double pi> = 3.14;
        return;
    }
}
```

`clinit` çš„ä¾‹å­ï¼šåœ¨ä½¿ç”¨è¯¥ç±»çš„æ—¶å€™ï¼Œå°±ä¼šæŠŠè¿™ä¸ªé™æ€å˜é‡åˆå§‹åŒ–è¿›æ¥

## Static Single Assignment (SSA)

All assignments in SSA are to variables with distinct names

- Give each definition a fresh name
- Propagate fresh name to subsequent uses
- Every variable has exactly one definition
  - What if a variable use is at control flow merges?
    - A special merge operator, Î¦ (called phi-function), is introduced to select the values at merge nodes 
    - Î¦(x_0, x_1) has the value x_0 if the control flow passes through the true part of the conditional and the value x_1 otherwise

**3AC ä¸‰åœ°å€ç **

```java
p = a + b
q = p - c
p = q * d
p = e - p
q = p + q
```

**SSA**

```java
p_1 = a + b
q_1 = p_1 - c
p_2 = q_1 * d
p_3 = e - p_2
q_2 = p_3 + q_1
```

### Why SSA?

- Flow information is indirectly incorporated into the unique variable names
  - May help deliver some simpler analyses, e.g., flow-insensitive analysis gains partial precision of flow sensitive analysis via SSA
- Define-and-Use pairs are explicit
  - Enable more effective data facts storage and propagation in some on-demand tasks 
  - Some optimization tasks perform better on SSA (e.g., conditional constant propagation, global value numbering)

### Why not SSA?

- SSA may introduce too many variables and phi-functions
- May introduce inefficiency problem when translating to machine code (due to copy operations) å› ä¸ºè¿˜è¦ç¿»è¯‘æˆæœºå™¨ç ï¼Œå› æ­¤ä¼šäº§ç”Ÿä¸€å®šçš„é—®é¢˜

## Control Flow Analysis

- Usually refer to building Control Flow Graph (CFG)
- CFG serves as the basic structure for static analysis
- The node in CFG can be an individual 3-address instruction, or (usually) a Basic Block

![](./figs/02_control_flow_analysis.png)

### Basic Blocks (BB)

Basic blocks (BB) are **maximal** sequences of consecutive three-address instructions with the properties that:

- It can be entered only at the begining, i.e., the first instruction in the block.
- It can be exited only at the end, i.e., the last instruction in the block 

![](./figs/02_bb_example.png)

**Try to design the algorithm to build BBs by yourself. åˆå§‹è‡ªå·±çš„æƒ³æ³•**

```java
// è‡ªç„¶å…¥å£
(1)  x = input 
(2)  y = x - 1
// è‡ªç„¶å‡ºå£

// (11) é‚£é‡Œ go to (3) è¿™é‡Œæœ‰ä¸€ä¸ªå…¥å£
(3)  z = x * y
(4)  if z < x goto (7)
// go to (7) ä»£è¡¨è¿™é‡Œ (7) æ˜¯å‡ºå£

// è‡ªç„¶å…¥å£
(5)  p = x / y
(6)  q = p + y
// è‡ªç„¶å‡ºå£

// å› æ­¤è¿™é‡Œ (7) æ˜¯ä¸€ä¸ªå…¥å£
(7)  a = q 
(8)  b = x + a
(9)  c = 2a - b
(10) if p == q goto (12)
// goto (12) æ˜¯ä¸€ä¸ªå‡ºå£

// goto (3) å› æ­¤æ˜¯ä¸€ä¸ªå‡ºå£ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå…¥å£
(11) goto (3)

// è‡ªç„¶å…¥å£å’Œå‡ºå£
(12) return 
```

#### How to build Basic Blocks 

**INPUT:** A sequence of three-address instructions of P

**OUTPUT:** A list of basic blocks of P 

**METHOD:** 

(1) Determine the leaders in P

- The first instruction in P is a leader 
- Any target instruction of a conditional or unconditional jump is a leader 
- Any instruction that immediately follows a conditional or unconditional jump is a leader 

(2) Build BBs for P

- A BB consists of a leader and all its subsequent instructions until the next leader

**å¯¹äºä¸Šè¿°çš„é—®é¢˜**

(1) Determine the leaders in P

- (1)
- (3), (7), (12)
- (5), (11), (12)

(2) Build BBs for P 

ä¸€å…±å…­ç»„

### Control Flow Graphs (CFG)

åœ¨ Basic Blocks çš„åŸºç¡€ä¸Šè¿›è¡Œå¡«è¾¹ 

- The nodes of CFG are basic blocks 
- There is an edge from block A to block B if and only if
  - There is a conditional or unconditional jump from the end of A to the beginning of B
  - B immediately follows A in the original order of instructions and A does not end in an unconditional jump 
  - ![](./figs/02_cfg_example1.png)
- It is normal to replace the jumps to instruction labels by jumps to basic blocks (In case of possibly frequent instruction-level changes)

![](./figs/02_cfg_2.png)

- A is a predecessor of B, and B is a successor of A 
- Usually we add two nodes, Entry and Exit 
  - They do not correspond to executable IR 
  - A edge from Entry to the BB containing the first instruction of IR 
  - A edge to Exit from any BB containing an instruction that could be the last instruction of IR 

![](./figs/02_cfg_3.png)

## æé—®

- ä¸ºä»€ä¹ˆä¸‰åœ°å€ç æ›´é€‚åˆé™æ€åˆ†æï¼Ÿ
  - ä¼ä¸šå¯èƒ½å­˜åœ¨ç‰¹åˆ«å¤šçš„ç¼–ç¨‹è¯­è¨€ï¼Œè€Œä¸‰åœ°å€ç æ˜¯ä¸ä¾èµ–è¯­è¨€çš„ï¼Œå› æ­¤æ›´åŠ é€‚åˆé™æ€åˆ†æ

- The relation between compilers and static analyzers
  - ç¼–è¯‘å™¨åœ¨å¾—åˆ°æœºå™¨ç ä¹‹å‰å’Œè¿›è¡Œè¯æ³•ã€è¯­æ³•ã€è¯­ä¹‰ç­‰å†…å®¹åï¼Œé€šè¿‡è½¬æ¢å™¨å¾—åˆ° IRï¼Œå¾—åˆ°IRåæ˜¯ç”¨äºé™æ€åˆ†æçš„

- Understand 3AC and its common forms (in IR jimple)
  - æ¯ä¸€ä¸ªä¸‰åœ°å€ç åŒ…æ‹¬è‡³å¤šä¸‰ä¸ªåœ°å€ï¼Œè‡³å¤šä¸€ä¸ªæ“ä½œç¬¦
    - bop: binary arithmetic or logical operation 
    - uop: unary operation (minus è´Ÿæ•°, negation å–å, casting ç±»å‹è½¬æ¢)  
    - L: a label to represent a program location  
    - rop: relational operator (>, <, ==, >=, <=, etc.) 
    - goto L: unconditional jump 
    - if ... goto L: conditional jump  

- How to build basic blocks on the top of IR
  - **INPUT:** A sequence of three-address instructions of P  
  - **OUTPUT:** A list of basic blocks of P   
  - **METHOD:**   
    - (1) Determine the leaders in P  
      - The first instruction in P is a leader
      - Any target instruction of a conditional or unconditional jump is a leader
      - Any instruction that immediately follows a conditional or unconditional jump is a leader
    - (2) Build BBs for P
      - A BB consists of a leader and all its subsequent instructions until the next leader 

- How to construct control flow graphs on top of BBs?
  - There is an edge from block A to block B if and only if
    - There is a conditional or unconditional jump from the end of A to the beginning of B
    - B immediately follows A in the original order of instructions and A does not end in an unconditional jump 